#include "gtest/gtest.h"
#include "bgmg_rand.h"
#include "SIMDxorshift/xorshift128plus.h"

#if defined(__AVX2__) 
#include "SIMDxorshift/simdxorshift128plus.h"
#endif

#include <random>
#include <iostream>

#define RDTSC_START(cycles)                                                   \
    do {                                                                      \
        register unsigned cyc_high, cyc_low;                                  \
        __asm volatile(                                                       \
            "cpuid\n\t"                                                       \
            "rdtsc\n\t"                                                       \
            "mov %%edx, %0\n\t"                                               \
            "mov %%eax, %1\n\t"                                               \
            : "=r"(cyc_high), "=r"(cyc_low)::"%rax", "%rbx", "%rcx", "%rdx"); \
        (cycles) = ((uint64_t)cyc_high << 32) | cyc_low;                      \
    } while (0)

#define RDTSC_FINAL(cycles)                                                   \
    do {                                                                      \
        register unsigned cyc_high, cyc_low;                                  \
        __asm volatile(                                                       \
            "rdtscp\n\t"                                                      \
            "mov %%edx, %0\n\t"                                               \
            "mov %%eax, %1\n\t"                                               \
            "cpuid\n\t"                                                       \
            : "=r"(cyc_high), "=r"(cyc_low)::"%rax", "%rbx", "%rcx", "%rdx"); \
        (cycles) = ((uint64_t)cyc_high << 32) | cyc_low;                      \
    } while (0)

/*
 * Prints the best number of operations per cycle where
 * test is the function call, answer is the expected answer generated by
 * test, repeat is the number of times we should repeat and size is the
 * number of operations represented by test.
 */
#define BEST_TIME(test, pre, repeat, size)                         \
        do {                                                              \
            printf("%s: ", #test);                                        \
            fflush(NULL);                                                 \
           for(int k = 0; k < 1; ++k){ uint64_t cycles_start, cycles_final, cycles_diff;             \
            uint64_t min_diff = (uint64_t)-1;                             \
            uint64_t max_diff = 0;                             \
            uint64_t result = 0;                              \
            for (int i = 0; i < repeat; i++) {                            \
                pre;                                                       \
                __asm volatile("" ::: /* pretend to clobber */ "memory"); \
                RDTSC_START(cycles_start);                                \
                result += test;                     \
                RDTSC_FINAL(cycles_final);                                \
                cycles_diff = (cycles_final - cycles_start);              \
                if (cycles_diff < min_diff) min_diff = cycles_diff;       \
                if (cycles_diff > min_diff) max_diff = cycles_diff;       \
            }                                                             \
            uint64_t S = size;                                            \
            float cycle_per_op = (min_diff) / (double)S;                  \
            float cycle_per_op2 = (max_diff) / (double)S;                  \
            float resultF = (result) / (double)repeat;                             \
            printf(" %.3f (%.3f) cycles per operation, output: %.1f  ", cycle_per_op, cycle_per_op2, resultF);}           \
            printf("\n");                                                 \
            fflush(NULL);                                                 \
 } while (0)

namespace {

class TestSubsetSampler {
 public:
  TestSubsetSampler(uint64_t key1, uint64_t key2) : generator_(key1, key2) {
  }

  uint32_t sample_geometric_step(uint32_t* data, float* buffer, uint32_t size, double p) {
    std::geometric_distribution<uint32_t> distribution(p);
    uint64_t loc = distribution(generator2_);
    uint32_t index = 0;
    for (;;) {
      data[size-index-1] = loc;
      index++;      
      loc += (1+distribution(generator2_));
      if (loc >= size) break;
    }
    // for (int i = (size - index); i < size; i++) buffer[data[i]] += 1.0f;
    return index;
  }  

  uint32_t sample_geometric_step_simd(uint32_t* data, float* buffer, uint32_t size, double p) {
    std::geometric_distribution<uint32_t> distribution(p);
    uint64_t loc = distribution(generator_);
    uint32_t index = 0;
    for (;;) {
      data[size-index-1] = loc;
      index++;      
      loc += (1+distribution(generator_));
      if (loc >= size) break;
    }
    // for (int i = (size - index); i < size; i++) buffer[data[i]] += 1.0f;
    return index;
  }  

 private:
#if defined(__AVX2__) 
  avx_xorshift128plus_engine generator_;
#else
  xorshift128plus_engine generator_;
#endif
  std::default_random_engine generator2_;
};

void TestSampler_impl_shuffle_simd(int repeats, int numel, double p) {
  SubsetSampler sampler(1,2,numel);
  TestSubsetSampler test_sampler(1,2);
  std::vector<uint32_t> data(numel, 0);
  std::vector<float> buffer(numel, 0.0f);
  BEST_TIME(sampler.sample_shuffle(p), 0, repeats, numel);
  BEST_TIME(test_sampler.sample_geometric_step_simd(&data[0], &buffer[0],numel, p), 0, repeats, numel);
  BEST_TIME(test_sampler.sample_geometric_step(&data[0],&buffer[0], numel, p), 0, repeats, numel);

  std::vector<int> values;
  for (int repeat = 0; repeat < 10; repeat++) {
    int count = sampler.sample_shuffle(p);
    values.resize(count, 0);
    for (int i = (numel - count), j = 0; i < numel; i++, j++) {
      uint32_t val = sampler.data()[i];
      ASSERT_LT(val, numel);
      ASSERT_GE(val, 0);
      values[j] = val;
    } 
    // check all values are unique
    std::sort(values.begin(), values.end());
    for (int i = 1; i < count; i++)
      ASSERT_NE(values[i-1], values[i]);
  }
}

// bgmg-test.exe --gtest_filter=Random.Sample
TEST(Random, ShuffleSimd_64K_1p0) {
  TestSampler_impl_shuffle_simd(10, 1024*64, 1);
}
TEST(Random, ShuffleSimd_64K_0p5) {
  TestSampler_impl_shuffle_simd(100, 1024*64, 0.5);
}
TEST(Random, ShuffleSimd_64K_0p1) {
  TestSampler_impl_shuffle_simd(1000, 1024*64, 0.1);
}
TEST(Random, ShuffleSimd_64K_0p01) {
  TestSampler_impl_shuffle_simd(10000, 1024*64, 0.01);
}
TEST(Random, ShuffleSimd_64K_0p001) {
  TestSampler_impl_shuffle_simd(100000, 1024*64, 0.001);
}
TEST(Random, ShuffleSimd) {
  int n = 60; int count = 0;
  SubsetSampler sampler(1,2,n);
  for (int j = 0; j < 4; j++) {
    for (int i = 0; i < n; i++) std::cout << sampler.data()[i] << " "; std::cout << "; count= " << count << std::endl;
    count = sampler.sample_shuffle(0.05);
  }
}

TEST(Random, xorshift128plus_shuffle32) {
  for (int size=1; size<48; size++) {
    //std::cout << "size:" << size << std::endl;
    xorshift128plus_key_t key;
    xorshift128plus_init(1234, 5432, &key);
    xorshift128plus_jump(&key); 
    std::vector<uint32_t> data(size, 0);
    for (int j=0; j < size; j++) {
      for (uint32_t i = 0; i < size; i++) data[i]=i;
      xorshift128plus_shuffle32_partial(&key, &data[0], size, j);
      //for (int i = 0; i < size; i++) std::cout << data[i] << " "; std::cout << std::endl;
    }
  }
}

#if defined(__AVX2__) 

TEST(Random, avx_xorshift128plus_shuffle32) {
  for (int size=1; size<48; size++) {
    //std::cout << "size:" << size << std::endl;
    avx_xorshift128plus_key_t key;
    avx_xorshift128plus_init(1234, 5432, &key);
    avx_xorshift128plus_jump(&key); 
    std::vector<uint32_t> data(size, 0);
    for (int j=0; j < size; j++) {
      for (uint32_t i = 0; i < size; i++) data[i]=i;
      avx_xorshift128plus_shuffle32_partial(&key, &data[0], size, j);
      //for (int i = 0; i < size; i++) std::cout << data[i] << " "; std::cout << std::endl;
    }
  }
}

#endif
    
}  // namespace
