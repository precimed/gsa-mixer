/*!
 * @mainpage
 * SEMT is a template based C++ library written to differentiate many-valued functions
 * in respect to a finite number of variables at compile-time.
 * @par Introduction
 * Basically, it teaches your compiler how to differentiate by representing single-valued functions
 * as type trees using static inheritance and "templated typedefs" to obtain the partial derivatives.
 * These type trees are generated by overloaded operators and global functions from leafs like unknowns and parameters,
 * the actual definition of a function is performed in the usual domain specific way C++ is popular for.
 * This technique is known as expression templates.
 *
 * @par Acknowledgments
 *
 * - The groundwork towards this library was done by Zvi Gutterman in his
 * thesis <em><A HREF="http://www.cs.technion.ac.il/~ssdl/thesis/finished/2004/ZviGutterman/">
            "Symbolic Pre-computation for Numerical Applications"</A></em>.
 * - Todd Veldhuizen - <em>"Expression Templates"</em>(1995).
 * - Andrei Alexandrescu - <em>"Modern C++ Design "</em>(2001).\n
 *   The <A HREF="http://sourceforge.net/projects/loki-lib/">library loki</A> is used in this project.
 * - Boost::enable_if and Boost::integral_constant, see <A HREF="http://boost.org"> the Boost library</A>.
 *
 * @par Getting Started
 * See the <b>README</b> file for instructions on compiling.
 *
 * Let's go and look at an example. You'll find it along others in the examples directory.
 *      @dontinclude semt_examples.cpp
 *      @skip int introduction
 *      @until ;
 * Because this is a template engine, instances mean nothing, most objects have no data at all.
 * Different variables are identified by different indicies, not by different objects. So another \c DINT(y,0);
 * would define just a different instance of the same variable. Instead of using named instances, you can also use
 * the macro \c VAR(0) to get a temporary instance of this variable.
 * Parameters and integral values are obtained by the same means.\n
 * We now actually define a function:
 *      @until endl
 * (\ref binops "See in the examples" what the generated type trees look like.) \n
 * While this was not very spectacular, the possibilities are now limited only by how much pain you want to inflict on your compiler:
 *      @until }
 * As you see, there are already some trivial simplifications performed, this feature is under construction.
 * The type returned \c by get_derivative() is VectorExpr, a simple homogenous container, that provides a bridge between
 * the function objects generated by SEMT and your favorite vector implementation (of course, std::vector by default, see \link api SEMT::Array\endlink ).
 *
 * @par Further steps
 *
 * - See a more complex @ref example.
 * - See details in the @ref api "user interface".
 * - Wanna kill your compiler? Check out the @ref advapi "advanced user interface".
 * - Extend SEMT, there is much space for improvement: new types (what about ones taking more than 2 arguments),
            new operators, new iterators and the simplifications need a thorough review...
 */

/*!
 * @page license License
 @verbatim
  ////////////////////////////////////////////////////////////////////////////////
  // The SEMT Library
  // Copyright (c) 2002 Zvi Gutterman
  // Copyright (c) 2010-2012 Stefan Gille
  // Permission to use, copy, modify, distribute and sell this software for any
  // purpose is hereby granted without fee, provided that the above copyright
  // notice appear in all copies and that both that copyright notice and this
  // permission notice appear in supporting documentation.
  // The authors make no representations about the
  // suitability of this software for any purpose. It is provided "as is"
  // without express or implied warranty.
  ////////////////////////////////////////////////////////////////////////////////
 @endverbatim
 */


/*
 * It seems like a good idea to encapsulate the whole function definition in a seperate class and link your algorithm
 * with the desired concrete function implementation. \n
 */

/*!
 * @page example Example
 *
 * Even without understanding the internal structure of SEMT, there is a lot you can do:
 *
 * - Create expressions by unary & binary operators from Variables, Parameters and Constants.
 * - Evaluate those expressions.
 * - Differentiate them as often as you wish, obtaining new expressions.
 * - Bundle several expressions in DifferentiableVectorExpr as a many-valued mapping and differentiate up to an arbitrary order.
 * \n
 *
 * The following section is generated from examples/semt_examples.cpp by \c make \c doc.\n
 * You can run the examples by calling \c make \c semt_example.
 *
 * @par Preconditions
 *      Include the neccessary header files. Semt's folder must be in the include path.
 *
 *      @dontinclude semt_examples.cpp
 *      @skip #include
 *      @until using namespace SEMT;
 *
 * @par Create Expessions
 * Use Variables, constant expressions and operators to form functions, that can be evaluated and differentiated.
 *
 *      @skip int full_example()
 *      @until // Haha
 *
 * @par Create & Differentiate Many-Valued Functions
 * Put several expressions in a box, called VectorExpr.
 *
 *      @skip // Make some more functions.
 *      @until } // end
 *
 */

/*!
 * @page info Useful Information
 * Look here if something goes wrong. (or to avoid this in the first place : )
 *
 * @par Reliability
 * There is no guarantee that anything will work, but it seemed like that with:
 *  - g++ 4.4.1 @ ubuntu 9.10 x86, single core.
 *  .
 * If the only issue is the missing auto keyword, you can use
 * @code
 *        typedef __typeof__((f_expr)) f_type;
 *        Expr<f_type> f_name;
 * @endcode
 * to instantiate expressions.
 *
 * @par Indexing restrictions
 * You have to start the indicies of the variables and parameters from zero upwards.
 * The reason is simple, they are used to access the container to retrieve the corresponding value.
 * See SEMT::Variable, SEMT::Parameter.
 *
 * @par Constants
 * Constants are somewhat tricky. I couldn't come up with any kind of overloaded operator (yet). If your constant is not
 * integer, using parameters seems a reasonable workaround.
 *
 * @par Bound checking
 * Bound checking is only performed in a minimal way by some assert macros. Use some constant or define to ensure
 * container size always match the neccessary conditions.\n
 * SEMT::VectorExpr provides \c vars() and \c size() to access them at runtime, but as you can see in the thorough example,
 * there is a easy way to get them as compile-time constants.
 *
 * @par Template instantiation depth
 * Your memory will probably exceed before you reach g++'s default limit of 1000.
 * But this is also a warning sign: Be aware of the complexity the differentiation requires.
 *
 * @par Simplifications
 * You should not disable this feature at the moment, the type bloat is immense.
 *
 * @par Compiler Firewall
 * If you are reading this out of boredom, waiting for code to compile, you may consider to
 * divide the definition of all SEMT functions and the use of them. Here is how to do it:
 * - Create a new translation unit.
 * - @link settings Configure SEMT@endlink and include "Semtfwd.h" in it's header.
 * - Provide an interface to access instances of SEMT::VectorExpr.
 * - Define your expressions in it's source file using SEMT::DifferentiableVectorExpr.
 * - Implement your interface to return the contents of DifferentiableVectorExpr via VectorExpr.
 * .
 * See also the example/semt_speed* files.
 * Uhh, almost forgot: It takes time anyway xD
 */

/*!
 * @page change Changelog
 *
 * @par SEMT 0.3
 *
 *      - added type traits
 *      - added RecursiveSimplifier, thus removed simplification completely out of the types
 *      - DifferentiableVectorExpr & Expr are now responsible for simplifying
 *      - IntIterator::actual_type now refers to member typedef simple_type of it's pointee
 *      - improved partial: differentiate to Integer<0> if not dependent
 *      - redesigned Defined_if
 *
 * @par SEMT 0.2
 *
 *		- added documentation, improved code styling, fixed a lot of bugs
 *		- added Shortcuts.h, Common.h: uselful macors & standard instantiations
 *		- added Conditions.h: conditional evaluation
 *		- added Parameter.h
 *		- added Foldr_t, foldr, foldl, Iterator concept
 *		- added sgn, inverse trigonometric functions, integral-exponent power type
 *		- refactored VectorExpr: provide strong exception safety
 *
 *
 * @par SEMT 0.1
 * 		The first useful version.
 */

/*!
 * All definitions begin with SEMT, contain only uppercase letters and are wrapped inside
 * "#ifndef ... #endif", just edit your copy of this file or redefine them via compiler switches
 * (make sure VectorExpr is compiled using the same definitions).
 * @defgroup settings Compile-time settings for SEMT
 */

/*!
 * This is what you're looking for, fast'n'dirty differentiation.
 * @defgroup    api User Interface
 */

/*!
 * @addtogroup api
 * @{
 */

/*!
 * These types represent constants.
 * Constant expressions differentiate to Integer<0>.
 * @defgroup  constexpr Constant expressions
 * @ingroup   nodes
 */

/*!
 * Basic binary operators for SEMT types.
 * These are placed in the global namespace.
 * @attention Be very careful about evaluation order.
 * @defgroup    binops Binary Operators
 * @par Example
 *      @dontinclude semt_examples.cpp
 *      @skip int binary_operators
 *      @until }
 */

/*!
 * Some unary operators for SEMT types.
 * @defgroup unops Unary Operators
 * @par Example
 *          For every unary type, there is a corresponding operator, so you can just do:
 *          @dontinclude semt_examples.cpp
 *          @skip int unary_operators
 *          @until }
 */

/*!
 * These types are not implemented and will produce compile-time errors if instantiated.
 * @defgroup    errtype     Error Types
 */

/// @} // group api

/*!
 * Dive deeper into SEMT's mechanics, use them to make life even harder for your compiler.
 * @defgroup    advapi Advanced User Interface
 */

/*!
 * @addtogroup advapi
 * @{
 */

/*!
 * The leaves of the type tree, comply to Expr's interface.
 * @defgroup    nodes Nodes
 */

/*!
 * Types representing the basic binary operations, comply to Expr's interface.
 * @defgroup    bintypes Binary Types
 * @see binops
 */

/*!
 * Types representing some unary operations, comply to Expr's interface.
 * @defgroup    untypes Unary Types
 * @see unops
 */


/*!
 * Produce a sequence of types in simple steps.
 * Fold_t complies to SEMT::Expr's interface.
 * @defgroup loops Lists, Loops & Fold
 * @par Example
 *          Simple example:
 *          @dontinclude semt_examples.cpp
 *          @skip int fold
 *          @until }
 *          \n Define your own lists:\n
 *          @dontinclude semt_examples.cpp
 *          @skip // xn / (n+1)
 *          @until // end
 * @par On the fly operators
 *      Bind the first argument of a binary type to a fixed type to get a new unary type.
 *      @dontinclude semt_examples.cpp
 *      @skip   // xn^2
 *      @until  } // end
 */

/*!
 * Check domain conditions at runtime.
 * Plug Defined_if and a conditional type together to report erroneous evaluations.
 * For example: @code
 * // Exp(Ln(f)) = f restr. to f > 0.
 * template<typename e> struct Exp_t<Ln_t<e> >
 * { typedef Defined_if<typename e::simple_type, GreaterThanZero, true> simple_type; };
 *          @endcode
 * @defgroup    cond Conditional evaluation
 */

/// @} // group advapi

/*!
 * Internal affairs.
 * @defgroup    dev Development
 */

/*!
 * Shortcuts for new types.
 * @defgroup    macros Macros used in SEMT
 * @ingroup     dev
 */

/*!
 * Predicates describing the hierarchy of SEMT types.
 * @defgroup    traits Type Traits
 * @ingroup     dev
 */

/*!
 * @addtogroup traits
 * @{
 */

/*!
 * @defgroup nodetraits Node Traits
 */

/*!
 * @defgroup bintraits Binary Operator Traits
 */

/*!
 * @defgroup un_traits Unary Operator Traits
 */

/// @} // group traits

/*!
 * Template specializations employed to redefine some expressions, under development.
 * The types in this category provide a typedef Result, a possibly simplified version
 * of the supplied argument.
 * The SFINAE principle and Boost::enable_if are employed heavily in this section.
 * You can disable all of them by setting SEMT_DISABLE_ALL_SIMPLIFICATIONS to 1.
 * The whole concept looks like the decorator pattern.
 * @defgroup    simpl Simplifications
 * @ingroup     dev
 * @see settings
 */

/*!
 * @namespace  SEMT
 * @bug Including Semtfwd.h may fail if VectorExpr is compiled seperate, because user settings are discarded if
 *      defined at the wrong place. Is this my concern?
 */

